<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>PSeInt Web — Intérprete completo (iframe)</title>
<style>
  :root{--bg:#071026;--panel:#0b1220;--muted:#0f1724;--text:#e6eef8;--accent:#6b5cff}
  *{box-sizing:border-box}
  body{margin:0;font-family:ui-monospace,monospace;background:linear-gradient(180deg,var(--bg),#000);color:var(--text)}
  header{padding:12px 18px;border-bottom:1px solid rgba(255,255,255,.03)}
  .wrap{max-width:1200px;margin:0 auto;display:flex;gap:12px;padding:12px}
  textarea{width:100%;height:340px;background:#041025;color:#bfe7c7;padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,.03);resize:vertical;font-family:ui-monospace,monospace}
  .left{flex:1;display:flex;flex-direction:column;gap:8px}
  .right{flex:1;display:flex;flex-direction:column;gap:8px}
  button{background:linear-gradient(135deg,var(--accent),#4ea7ff);border:none;color:white;padding:10px 12px;border-radius:8px;cursor:pointer;font-weight:700}
  iframe{width:100%;height:520px;border-radius:8px;border:1px solid rgba(255,255,255,.04);background:#000}
  .controls{display:flex;gap:8px;align-items:center}
  .small{font-size:13px;color:#bcd}
</style>
</head>
<body>
<header><h2 style="margin:0">PSeInt Web — Intérprete Completo (Iframe)</h2></header>

<div class="wrap">
  <div class="left">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div>
        <strong>Editor (PSeInt)</strong>
        <div class="small">Guarda automáticamente. Usa Ctrl/Cmd+Enter para ejecutar.</div>
      </div>
      <div class="controls">
        <button id="runBtn">▶ Ejecutar (iframe)</button>
        <button id="downloadBtn">⬇ Descargar .pse</button>
      </div>
    </div>

    <textarea id="editor" spellcheck="false"></textarea>
    <div class="small">Sintaxis soportada: Algoritmo, Definir, Leer, Escribir, Mostrar, SI/SINO/SI, REPETIR, MIENTRAS, PARA, SEGUN, MOD, DIV, ^, operadores lógicos.</div>
  </div>

  <div class="right">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div><strong>Ejecutor (Iframe aislado)</strong></div>
      <div class="small">Interacción: inputs aparecen dentro del iframe cuando el programa usa LEER.</div>
    </div>
    <iframe id="runner" sandbox="allow-scripts"></iframe>
  </div>
</div>

<script>
/* ---------------------------
  UI + persistence
  --------------------------- */
const editor = document.getElementById('editor');
const runBtn = document.getElementById('runBtn');
const downloadBtn = document.getElementById('downloadBtn');
const runner = document.getElementById('runner');

const LS_KEY = 'pseint_web_program_v1';
if(localStorage.getItem(LS_KEY)) editor.value = localStorage.getItem(LS_KEY);
else editor.value = `Algoritmo cajero
Definir cuenta, clave, retiro, m Como Entero
saldo <- 1000000
Escribir "Ingresar numero de cuenta"
Leer cuenta
Escribir "Ingresar clave"
Leer clave
Si cuenta = 526082 Entonces
  Si clave = 123 Entonces
    Escribir "HAZ INGRESADO CON EXITO"
    Mostrar "Tienes de saldo: ", saldo
    Escribir "Ingresar saldo a retirar"
    Leer retiro
    m <- saldo - retiro
    Escribir "Su saldo actual es de: ", m
  SINO
    Escribir "VUELVE A INTENTARLO"
  FIN_SI
SINO
  Escribir "Cuenta no encontrada"
FIN_SI
FinAlgoritmo`;

editor.addEventListener('input', ()=> localStorage.setItem(LS_KEY, editor.value));
editor.addEventListener('keydown', e => { if((e.ctrlKey||e.metaKey) && e.key === 'Enter'){ e.preventDefault(); run(); } });

downloadBtn.onclick = () => {
  const a = document.createElement('a');
  a.href = URL.createObjectURL(new Blob([editor.value], {type:'text/plain'}));
  a.download = 'programa.pse';
  a.click();
};

/* ---------------------------
  When run: we create iframe content (srcdoc) that contains
  a full interpreter implementation (no eval for expressions).
  The interpreter inside iframe will:
    - parse lines
    - evaluate expressions with shunting-yard -> RPN
    - control flow blocks: SI/SINO/FINSI, MIENTRAS, REPETIR/HASTA, PARA, SEGUN
    - LEER shows an input element in the iframe and pauses until entered
--------------------------- */

runBtn.addEventListener('click', run);

function run(){
  const code = editor.value;
  // Prepare iframe srcdoc
  const src = `<!doctype html><html lang="es"><head><meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Runner</title>
  <style>
    body{font-family:ui-monospace,monospace;background:#000;color:#0f0;padding:12px}
    #console{white-space:pre-wrap;font-size:14px}
    .input-row{margin-top:8px}
    input[type="text"]{background:#011; border:1px solid #0f0;color:#0f0;padding:6px;border-radius:6px}
    button{background:#0f0;color:#000;border:none;padding:6px;border-radius:6px;cursor:pointer}
    .chip{display:inline-block;padding:6px 8px;border-radius:6px;background:#021}
  </style>
  </head><body>
    <div id="console"></div>
    <div id="controls"></div>
  <script>
  // --- utilities: tokenizer + shunting-yard expression evaluator (no eval) ---
  function isNumeric(s){ return /^-?\\d+(\\.\\d+)?$/.test(s); }
  function isIdent(s){ return /^[A-Za-z_][A-Za-z0-9_]*$/.test(s); }

  // Operator precedence and associativity
  const OPS = {
    'NO': {prec:5, assoc:'right', unary:true},
    '^': {prec:4, assoc:'right'},
    '*': {prec:3, assoc:'left'}, '/': {prec:3, assoc:'left'}, 'MOD': {prec:3, assoc:'left'},
    '+': {prec:2, assoc:'left'}, '-': {prec:2, assoc:'left'},
    '>':{prec:1,assoc:'left'}, '<':{prec:1,assoc:'left'}, '>=':{prec:1,assoc:'left'}, '<=':{prec:1,assoc:'left'}, '=':{prec:1,assoc:'left'}, '<>':{prec:1,assoc:'left'},
    'Y':{prec:0,assoc:'left'}, 'O':{prec:0,assoc:'left'}
  };

  // normalize token stream: replace words, handle <> and >= <=, tokens
  function tokenizeExpr(s){
    // replace logical words with uppercase tokens (preserve strings in quotes)
    let parts = [];
    let i=0;
    while(i<s.length){
      const ch=s[i];
      if(ch === '\"' || ch === \"'\"){
        const q=ch; let j=i+1; while(j<s.length && s[j]!==q) j++; parts.push(s.slice(i,j+1)); i=j+1; continue;
      }
      if(/\\s/.test(ch)){ i++; continue; }
      // multi-char ops
      if(s.slice(i,3) === '<>'){ parts.push('<>'); i+=2; continue; }
      if(s.slice(i,2) === '>=' || s.slice(i,2) === '<='){ parts.push(s.slice(i,2)); i+=2; continue; }
      if(/[-+*\\/^(),<>]/.test(ch)){ parts.push(ch); i++; continue; }
      // word token (ident or keyword or number)
      let j=i;
      while(j<s.length && /[A-Za-z0-9_.]/.test(s[j])) j++;
      let w = s.slice(i,j);
      // map some keywords
      if(/^mod$/i.test(w)) parts.push('MOD');
      else if(/^div$/i.test(w)) parts.push('DIV');
      else if(/^y$/i.test(w)) parts.push('Y');
      else if(/^o$/i.test(w)) parts.push('O');
      else if(/^no$/i.test(w)) parts.push('NO');
      else parts.push(w);
      i=j;
    }
    // replace DIV with function tokens: we'll handle DIV when evaluating
    return parts;
  }

  function toRPN(tokens){
    let out = [], ops = [];
    for(let i=0;i<tokens.length;i++){
      let t=tokens[i];
      if(typeof t === 'string' && /^['\\"]/.test(t)){ out.push(t); continue; } // string literal
      if(isNumeric(t)){ out.push(t); continue; }
      if(isIdent(t)){ out.push(t); continue; }
      if(t==='DIV'){ // treat as operator with precedence of *
        while(ops.length && ((OPS[ops[ops.length-1]] && ((OPS[ops[ops.length-1]].prec > OPS['*'].prec) || (OPS[ops[ops.length-1]].prec===OPS['*'].prec && OPS[ops[ops.length-1]].assoc==='left'))))) out.push(ops.pop());
        ops.push('DIV'); continue;
      }
      if(t in OPS){
        const o1 = t;
        while(ops.length){
          const o2 = ops[ops.length-1];
          if(!(o2 in OPS)) break;
          const a1 = OPS[o1], a2 = OPS[o2];
          if((a1.assoc === 'left' && a1.prec <= a2.prec) || (a1.assoc === 'right' && a1.prec < a2.prec)){
            out.push(ops.pop());
          } else break;
        }
        ops.push(o1);
        continue;
      }
      if(t === '('){ ops.push(t); continue; }
      if(t === ')'){
        while(ops.length && ops[ops.length-1] !== '(') out.push(ops.pop());
        ops.pop();
        continue;
      }
      // else push as literal
      out.push(t);
    }
    while(ops.length) out.push(ops.pop());
    return out;
  }

  function evalRPN(rpn, vars){
    const st = [];
    for(const tok of rpn){
      if(isNumeric(tok)) st.push(Number(tok));
      else if(typeof tok === 'string' && /^['\\"]/.test(tok)) st.push(tok.slice(1,-1));
      else if(isIdent(tok)){
        st.push( (tok in vars) ? vars[tok] : 0 );
      } else if(tok === 'MOD'){
        const b = st.pop(), a = st.pop(); st.push(a % b);
      } else if(tok === 'DIV'){
        const b = st.pop(), a = st.pop(); st.push(Math.floor(a / b));
      } else if(tok === '^'){
        const b = st.pop(), a = st.pop(); st.push(Math.pow(a,b));
      } else if(tok === '*'){ const b=st.pop(), a=st.pop(); st.push(a*b); }
      else if(tok === '/'){ const b=st.pop(), a=st.pop(); st.push(a/b); }
      else if(tok === '+'){ const b=st.pop(), a=st.pop(); st.push(a+b); }
      else if(tok === '-'){ const b=st.pop(), a=st.pop(); st.push(a-b); }
      else if(tok === '>'){ const b=st.pop(), a=st.pop(); st.push(a>b); }
      else if(tok === '<'){ const b=st.pop(), a=st.pop(); st.push(a<b); }
      else if(tok === '>='){ const b=st.pop(), a=st.pop(); st.push(a>=b); }
      else if(tok === '<='){ const b=st.pop(), a=st.pop(); st.push(a<=b); }
      else if(tok === '=' ){ const b=st.pop(), a=st.pop(); st.push(a==b); }
      else if(tok === '<>'){ const b=st.pop(), a=st.pop(); st.push(a!=b); }
      else if(tok === 'Y'){ const b=st.pop(), a=st.pop(); st.push( (!!a) && (!!b) ); }
      else if(tok === 'O'){ const b=st.pop(), a=st.pop(); st.push( (!!a) || (!!b) ); }
      else if(tok === 'NO'){ const a=st.pop(); st.push(!a); }
      else { /* unknown token: push as is */ st.push(tok); }
    }
    return st.length ? st[st.length-1] : 0;
  }

  // evaluate an expression string given vars
  function evalExprText(expr, vars){
    if(expr == null) return 0;
    const tokens = tokenizeExpr(expr);
    const rpn = toRPN(tokens);
    return evalRPN(rpn, vars);
  }

  // --- Interpreter: parse pseudocode lines and execute control flow ---
  (function interpreter(){
    const raw = ${JSON.stringify(code)};
    const linesRaw = raw.split(/\\n/);
    // pre-process: split by lines and keep original for block scanning
    const lines = linesRaw.map(l => l.replace(/\\r/g,''));
    const vars = {};
    const consoleDiv = document.getElementById('console');
    const controls = document.getElementById('controls');

    function write(...xs){
      consoleDiv.innerHTML += xs.map(x=> (typeof x === 'object' ? JSON.stringify(x) : String(x)) ).join(' ') + '\\n';
    }
    function showInline(...xs){
      // append to last line without newline
      consoleDiv.innerHTML += xs.map(x=>String(x)).join(' ');
    }

    // runtime program counter and block stack
    let pc = 0;
    const callStack = []; // to support loops (store return positions)

    // helper to skip-to matching FIN_SI / FIN_MIENTRAS / FIN_PARA / FIN_SEGUN
    function findMatching(endKeywords, startIdx){
      // used when need to skip a block
      let depth = 0;
      for(let i = startIdx; i < lines.length; i++){
        const t = lines[i].trim();
        if(/^SI\\b/i.test(t) && /^FIN_SI/i.test(endKeywords.join(' '))){ depth++; }
        if(/^MIENTRAS\\b/i.test(t) && endKeywords.includes('FIN_MIENTRAS')) depth++;
        if(/^REPETIR\\b/i.test(t) && endKeywords.includes('HASTA QUE')) depth++;
        if(/^PARA\\b/i.test(t) && endKeywords.includes('FIN_PARA')) depth++;
        if(/^SEGUN\\b/i.test(t) && endKeywords.includes('FIN_SEGUN')) depth++;
        // check ends
        if(endKeywords.some(kw => new RegExp('^'+kw+'$','i').test(t))){
          if(depth === 0) return i;
          else depth--;
        }
      }
      return -1;
    }

    // main step: executes until a LEER requires input or program ends
    function step(){
      while(pc < lines.length){
        let rawLine = lines[pc];
        let line = rawLine.trim();
        pc++;
        if(!line || /^Algoritmo\\b/i.test(line) || /^FinAlgoritmo\\b/i.test(line) || /^\\/\\/.test(line)) continue;

        // DEFN: Definir a, b como entero
        let m;
        if(m = line.match(/^Definir\\s+(.+)\\s+Como\\s+([A-Za-z]+)/i)){
          const names = m[1].split(',').map(s=>s.trim());
          names.forEach(n => { if(!(n in vars)) vars[n] = 0; });
          continue;
        }

        // LEER var
        if(m = line.match(/^Leer\\s+([A-Za-z_]\\w*)/i)){
          const v = m[1];
          // create input element, pause execution until Enter pressed
          const row = document.createElement('div'); row.className = 'input-row';
          const inp = document.createElement('input'); inp.type='text';
          inp.placeholder = 'Ingrese ' + v;
          const btn = document.createElement('button'); btn.textContent = 'OK';
          row.appendChild(inp); row.appendChild(btn);
          controls.appendChild(row);
          inp.focus();
          // when user submits, set var and resume
          const resume = () => {
            let val = inp.value;
            // try to convert to number, or boolean if VERDADERO/FALSO
            if(/^\\d+$/.test(val)) val = parseInt(val,10);
            else if(/^\\d+\\.\\d+$/.test(val)) val = parseFloat(val);
            else if(/^VERDADERO$/i.test(val)) val = true;
            else if(/^FALSO$/i.test(val)) val = false;
            vars[v] = val;
            controls.removeChild(row);
            step(); // resume
          };
          btn.addEventListener('click', resume);
          inp.addEventListener('keydown', (ev)=>{ if(ev.key==='Enter') resume(); });
          return; // pause
        }

        // ESCRIBIR / MOSTRAR
        if(m = line.match(/^(Escribir|Mostrar)\\s+(.+)/i)){
          const kind = m[1].toUpperCase();
          const rest = m[2].trim();
          // split by commas but respecting quoted strings
          const args = splitArgsTopLevel(rest);
          const vals = args.map(a => {
            a = a.trim();
            if(/^['\\"]/.test(a)) return a.slice(1,-1);
            // evaluate expression
            return evalExprText(a, vars);
          });
          if(kind === 'ESCRIBIR') write(...vals);
          else showInline(...vals);
          continue;
        }

        // SI ... ENTONCES  (and SINO SI / SINO / FIN_SI)
        if(m = line.match(/^SI\\s+(.+)\\s+ENTONCES$/i)){
          const condExpr = m[1];
          const cond = !!evalExprText(condExpr, vars);
          if(!cond){
            // skip to SINO, SINO SI, or FIN_SI at same level
            let depth = 0;
            for(let i = pc; i < lines.length; i++){
              const t = lines[i].trim();
              if(/^SI\\b/i.test(t)) depth++;
              if(/^FIN_SI\\b/i.test(t)){
                if(depth === 0){ pc = i+1; break; }
                else depth--;
              }
              if(depth === 0 && (/^SINO\\b/i.test(t) || /^SINO SI\\b/i.test(t))){ pc = i+1; break; }
            }
          }
          continue;
        }
        if(/^SINO SI\\b/i.test(line)){
          // If we arrived here it means previous SI was true and jumped past SINO blocks.
          // So we should skip until FIN_SI
          // skip to FIN_SI
          let depth = 0;
          for(let i = pc; i < lines.length; i++){
            const t = lines[i].trim();
            if(/^SI\\b/i.test(t)) depth++;
            if(/^FIN_SI\\b/i.test(t)){
              if(depth === 0){ pc = i+1; break; }
              else depth--;
            }
          }
          continue;
        }
        if(/^SINO\\b/i.test(line)){
          // execution continues in SINO block; nothing special here
          continue;
        }
        if(/^FIN_SI\\b/i.test(line)){
          continue;
        }

        // MIENTRAS cond HAGA ... FIN_MIENTRAS
        if(m = line.match(/^MIENTRAS\\s+(.+)\\s+HAGA$/i)){
          const cond = m[1];
          // if condition false, skip to FIN_MIENTRAS
          if(!evalExprText(cond, vars)){
            // find matching FIN_MIENTRAS considering nested MIENTRAS
            let depth = 0;
            for(let i = pc; i < lines.length; i++){
              const t = lines[i].trim();
              if(/^MIENTRAS\\b/i.test(t)) depth++;
              if(/^FIN_MIENTRAS\\b/i.test(t)){
                if(depth === 0){ pc = i+1; break; }
                else depth--;
              }
            }
          } else {
            // condition true: push loop start position (pc-1) so we can return after FIN_MIENTRAS
            callStack.push({type:'MIENTRAS', pos: pc-1, cond: cond});
          }
          continue;
        }
        if(/^FIN_MIENTRAS\\b/i.test(line)){
          // pop last MIENTRAS
          const top = callStack.length ? callStack[callStack.length-1] : null;
          if(top && top.type === 'MIENTRAS'){
            // re-evaluate condition; if true, jump back to start
            if(evalExprText(top.cond, vars)){
              pc = top.pos + 1;
            } else {
              callStack.pop();
            }
          }
          continue;
        }

        // REPETIR ... HASTA QUE cond
        if(/^REPETIR\\b/i.test(line)){
          // mark repeat start
          callStack.push({type:'REPETIR', pos: pc});
          continue;
        }
        if(m = line.match(/^HASTA QUE\\s+(.+)$/i)){
          const cond = m[1];
          const top = callStack.length ? callStack[callStack.length-1] : null;
          if(top && top.type === 'REPETIR'){
            if(!evalExprText(cond, vars)){
              // jump back to start of repeat (position after REPEAT)
              pc = top.pos;
            } else {
              callStack.pop();
            }
          }
          continue;
        }

        // PARA v <- inicio HASTA fin [CON PASO p]
        if(m = line.match(/^PARA\\s+([A-Za-z_]\\w*)\\s*<-\\s*(.+)\\s+HASTA\\s+(.+?)(?:\\s+CON\\s+PASO\\s+(.+))?$/i)){
          const v = m[1];
          const inicio = evalExprText(m[2], vars);
          const fin = evalExprText(m[3], vars);
          const paso = m[4] ? evalExprText(m[4], vars) : 1;
          vars[v] = inicio;
          callStack.push({type:'PARA', pos: pc, v:v, fin:fin, paso:paso});
          continue;
        }
        if(/^FIN_PARA\\b/i.test(line)){
          const top = callStack.length ? callStack[callStack.length-1] : null;
          if(top && top.type === 'PARA'){
            vars[top.v] = vars[top.v] + top.paso;
            if(top.paso >= 0 ? vars[top.v] <= top.fin : vars[top.v] >= top.fin){
              // continue loop: set pc back to just after PARA
              pc = top.pos + 0; // because pc has already advanced, we set to top.pos+0 so next iteration starts after PARA handling
            } else {
              // exit loop
              callStack.pop();
            }
          }
          continue;
        }

        // SEGUN var HACER ... [DE OTRO MODO:] ... FIN_SEGUN
        if(m = line.match(/^SEGUN\\s+(.+)\\s+HACER$/i)){
          const selectorRaw = m[1].trim();
          const selector = evalExprText(selectorRaw, vars);
          // scan cases until FIN_SEGUN, execute matching case or default
          let matched = false;
          let j = pc;
          for(; j < lines.length; j++){
            const t = lines[j].trim();
            if(/^FIN_SEGUN\\b/i.test(t)){ pc = j+1; break; }
            const caseMatch = t.match(/^(.+?):\\s*(.*)$/i);
            if(caseMatch){
              const labelRaw = caseMatch[1].trim();
              const restInline = caseMatch[2];
              if(!matched && evalExprText(labelRaw, vars) == selector){
                // execute this case block: if inline rest, execute it, else process subsequent lines until break (next cas
